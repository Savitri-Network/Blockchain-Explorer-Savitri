## Step 7 · Referenced But Not Implemented Services

| Placeholder / Reference | Expected behaviour | Data format & interfaces | Implementation guidelines |
| --- | --- | --- | --- |
| `@/utils/serverEnv` → `buildApiUrl(domain: string, sub?: string)` | Restituire l’URL completo per le chiamate al backend Savitri in base all’ambiente (dev/stage/prod). Supportare domini logici (`tx`, `block`, `sc`) e sottopercorsi (`hash`, `pk`, `ts`) | Input: `("tx","hash")` → Output: `https://api.savitri.io/tx/hash` (string). Dovrebbe leggere variabili d’ambiente: `API_BASE_URL`, `API_TIMEOUT`, `API_KEY` opzionale | Creare file `utils/serverEnv.ts`. Gestire fallback, validazione dei parametri e sollevare errori se la variabile env manca |
| `@/utils/validation` → `validateId`, `validatePaginationParams` | Validare stringhe identificative (hash, indirizzi, timestamp) e parametri di paginazione/sorting | `validateId(value: string): boolean` <br> `validatePaginationParams(page?: string, size?: string, sort?: string): { valid: boolean; params?: { page: number; size: number; sort: "asc" | "desc" }; error?: string }` | File `utils/validation.ts` con regex (es. `^0x[a-fA-F0-9]{64}$` per hash) e limiti (page ≥1, size ≤100). Integrare test unitari |
| `app/api/stats/route.ts` | Endpoint server-side che recupera e normalizza KPI (TPS, gas, supply, validators) | Output JSON: `{ tps: number, avgGas: number, totalTx24h: number, supply: string, validatorsOnline: number, chart: DataPoint[] }` | Analizzare fonti: backend Savitri deve fornire endpoint dedicato oppure calcoli su database. Implementare caching con `revalidate` |
| `app/api/userchart/route.ts` | Fornire dataset per grafici utente (es. volume tx per indirizzo) | Output: `{ labels: string[], values: number[] }` | Simile a `barchart`, ma orientato ad analisi per utente |
| Componenti UI (`components/**`) | Rendering di layout, liste, sezioni contratti | Strutture React ben tipizzate, con props definite e styled components / CSS modules | Creare un sistema di design (colori, tipografia) e convertire le esigenze funzionali (liste blocchi, transazioni, card stats) in componenti riutilizzabili |
| Global layout & pages (`app/layout.tsx`, `app/page.tsx`, etc.) | Strutturare la shell applicativa (header, footer, contenuti) e le singole pagine di dominio | Standard Next App Router: definire metadata, font, provider globali. `app/page.tsx` → dashboard; `app/blocks/page.tsx` → lista blocchi; `app/blocks/[id]/page.tsx` → dettaglio blocco | Introdurre loader (`loading.tsx`) e fallback (`error.tsx`) per gestire suspense e error boundaries |
| Configurazioni di progetto (`package.json`, `tsconfig.json`, `next.config.js`) | Setup build, dev server, linting | --- | Creare nuova scaffolding Next (`npx create-next-app@latest savitri-explorer`). Trasferire le API route già presenti nelle corrispettive directory |
| Monitoring & analytics | Logging strutturato, error tracking, metriche performance | Log JSON con `requestId`, `route`, `duration`. Eventuale Sentry/Datadog | Introdurre `utils/logger.ts`, hooking nelle API route per registrare start/stop, errori e tempi di risposta |

